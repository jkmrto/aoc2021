use std::collections::HashMap;
use std::fs;

#[allow(dead_code)]
fn exec1(filename: &str) -> i32 {
    let contents = fs::read_to_string(filename).expect("error");
    let split_content: Vec<&str> = contents.trim().split("\n\n").collect();

    let mut register: HashMap<(char, char), char> = HashMap::new();

    let mut sequence: Vec<char> = split_content[0].chars().collect();
    println!(" sequence: {:?}", sequence);

    let insertion_rules_raw: Vec<&str> = split_content[1].split("\n").collect();
    println!("{:?}", insertion_rules_raw);

    for rule_raw in insertion_rules_raw {
        let rule_raw_vec: Vec<&str> = rule_raw.trim().split(" -> ").collect();
        let rule_raw_input_vec: Vec<char> = rule_raw_vec[0].chars().collect();
        let rule_raw_output_vec: Vec<char> = rule_raw_vec[1].chars().collect();
        register.insert(
            (rule_raw_input_vec[0], rule_raw_input_vec[1]),
            rule_raw_output_vec[0],
        );
    }
    println!("register: {:?}", register);

    let steps = 10;
    for i in 0..steps {
        let mut vec = Vec::new();
        for i in 0..(sequence.len() - 1) {
            vec.push(sequence[i]);
            vec.push(*register.get(&(sequence[i], sequence[i + 1])).unwrap())
        }
        vec.push(sequence[sequence.len() - 1]);
        sequence = vec.clone();

        println!("Step {}, vec: {:?}", i + 1, vec);
    }

    let mut occurrences: HashMap<char, i32> = HashMap::new();
    for elem in sequence {
        *occurrences.entry(elem).or_default() += 1;
    }

    println!("occurrences: {:?}", occurrences.values());

    let max = occurrences.values().max().unwrap();
    let min = occurrences.values().min().unwrap();
    println!("min, max: ({}, {})", min, max);

    return max - min;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn day14_exec1() {
        assert_eq!(exec1("input/day14/example.txt"), 1588);
        assert_eq!(exec1("input/day14/input.txt"), 5656);
    }
}
